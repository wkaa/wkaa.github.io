---
layout: post
title: 为什么程序员无法分清万圣节和圣诞节
categories: C
description: C专家编程读书会分享
keywords: C语言 C专家编程
---

　　这是`C专家编程`的第八章，在这里进行一个分享

　　为什么程序员无法分清万圣节和圣诞节呢？当然这时一个冷笑话，原因是八进制的31等于十进制的25，也就是说10月31日（万圣节前夜）等于12月25日。

## 根据位模式构筑图形

　　这里定义了黑白位图，一个位表示一个像素，如果位被设置，位就是亮的，反之就是暗的。在C语言中，典型的16X16的黑白图形可能如下：

```
static unsigned short stopwatch[] = {
    0x07C6,
    0x1FF7,
    .
    .
    .
    0x0000
}
```

　　书里提供了一个**惊人**的`#define`定义的优雅集合，允许程序建立常量使它们看上去像是屏幕上的图形。

```
#define X )*2+1
#define _ )*2
#define s ((((((((((((((((0 /* 用于建立16位宽的图形 */
```

　　这样定义之后以上例子就会变为

```
static unsigned short stopwatch[] = {
    s _ _ _ _ _ X X X X X _ _ _ X X _,
    s _ _ _ X X X X X X X X X _ X X X,
    .
    .
    .
}
```

　　太多了，就不全部打出来了:joy::joy::joy:

> 别忘了在画图结束后清除宏定义，不然可能会给后面的代码带来不可预测的后果

## 数据类型提升

　　从一个小例子开始

```
printf("%d", sizeof('A'));
```

　　你以为输出结果就是1吗，实际上应该是4（或者是你机器上`int`的长度），这个特性被称为**类型提升**，提升的规则是整型类型都提升到`int`，浮点类型提升到`double`，任何数组提升到相应类型的指针

　　***任何数组提升到相应类型的指针，这句话不是太懂，另外对于长整型就没有提升了？long long这样的呢***

> 警惕！真正值得注意之处————参数也会被提升！

　　书中举了个`printf`的例子，在`Sun OS`上把`long long`传给%d参数会发生错误，无法取得正确的值，我在自己机器上测试了一下，并不会出错，书上说的原理是因为`printf`函数根据%d的参数只会从堆栈中去`int`类型长度的字节，因此无法获取正确的数据。

　　C语言中类型转换的原因是简化了代码的生成，都统一成一样的长度，压到堆栈中的参数都是同一长度的，运行时只需要直到参数的数目，而不需要直到它们的长度。

## 函数原型

　　如果申明了函数原型，参数提升就不会发生，照着书里的代码测试了一下，在不申明的情况下调用另一个文件里的函数，确实得到的是错误的数据

```
文件1：
void newdef(float d, char i)
{
    printf("newdef:float = %f, char = %d\n", d, i);
}

文件2：
float d = 10.0;
char j = 3;
newdef(d, j);

输出：
newdef:float = 0.000000, char = 0
```

　　对函数进行申明后输出正确，做了另外一个测试，将文件1中的`float`和`char`改为了`double`和`int`，这样在不申明的情况下也能输出正常，这也就验证了，在没有申明的情况下，编译器对类型进行了提升，导致函数获取的数据有误。

## 不需要回车键就能得到一个字符

　　在UNIX不好实现逐个字符的获取，书里提供了两种方法，这里就不赘述了，直接看书就好了，大致概括如下

```
1. 修改终端输入模式，改成一次一字符，记得用完改回来

2. 通过ioctl轮询获取字符
```

## 有限状态机

　　使用函数指针数组实现有限状态机，要求所有函数接受同样的参数，并返回同种类型的返回值

## 类型强制转换

　　为了消除类型歧义，使编译器可以从一开始就选用正确的位模式。
